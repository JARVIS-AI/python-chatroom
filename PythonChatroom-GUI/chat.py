# -*- coding: utf-8 -*-
# Created By Mr.Hidden
import asyncio
from tkinter import *
from _client import *

from models import SavedMessage

# Initialize the main window
root = Tk()
# Set the window title
root.title("Chat Room")
width = int(root.winfo_screenwidth())
height = int(root.winfo_screenheight())
right_left = str((int(width) - 800) // 2)
top_down = str((int(height) - 600) // 2)
root.resizable(width=False, height=False)
root.minsize(50,  30)
root.geometry(f"+{right_left}+{top_down}")
# root.attributes('-topmost', True)
root.config(background="#156760")
root.update()

# Variable to store the username
username = StringVar()

# Main container for the application
_main = Frame(root)
_main.pack()

# Container for the login section
_login_frame = Frame(_main)

# Label for the username field
username_lbl = Label(_login_frame, text="Username:")
username_lbl.grid(row=0, column=0)

# Entry widget for the username
username_txt = Entry(_login_frame, textvariable=username)
username_txt.grid(row=0, column=1)
# Focus on the username entry widget
username_txt.focus_set()

# Button for logging in
login_btn = Button(_login_frame, text="Login")
login_btn.grid(row=0, column=2)

# Label for the username error field
username_error_lbl = Label(_login_frame, text="username must be EN", foreground="red", state="disabled")
username_error_lbl.grid(row=1, column=0, columnspan=2)


# Function to handle the Enter key press event for login
def on_enter_press(event):
    """
    This function checks for the Enter key press event in the username entry widget.
    If the Enter key is pressed, it simulates a click on the login button by calling its `invoke` method.

    Args:
        event (Tkinter event object): The event object generated by the key press.
    """
    if event.keysym == "Return":
        try:
            login_btn.invoke()
        except:
            pass


# Bind the Enter key press event
username_txt.bind("<KeyPress>", on_enter_press)

# Container for displaying messages
_message_frame = Frame(_main)

# Scrollbar for the message display area
message_scroll = Scrollbar(_message_frame)
message_scroll.grid(row=0, column=2, sticky="nsew")

# Text widget for displaying messages
messages_box_txt = Text(
    _message_frame, yscrollcommand=message_scroll.set, background="#bfd6ff", font=80, width =40,
    state="disabled", wrap="word"
)
# Define tag colors
messages_box_txt.tag_configure("normaltext", foreground="black")
messages_box_txt.tag_configure("new_user", foreground="green")
messages_box_txt.tag_configure("server", foreground="blue")
messages_box_txt.tag_configure("server_exit", foreground="red")
messages_box_txt.tag_configure("server_enter", foreground="green")
messages_box_txt.tag_configure("user_msg", foreground="magenta")
messages_box_txt.tag_configure('rtl', justify=RIGHT)

messages_box_txt.grid(row=0, column=0, columnspan=1)
# Configure the message_scroll
message_scroll.config(command=messages_box_txt.yview)

# Container for the message input and send button
_input_frame = Frame(_main)

# Entry widget for typing messages
message_txt = Entry(
    _input_frame, background="#92e7f5", width=35, foreground="black", bd=5, 
    font=30, state=DISABLED,
)
message_txt.grid(row=0, column=0, columnspan=3)


# Function to handle the Enter key press event for sending messages
def on_enter(event):
    """
    This function handles the Enter key press event in the message entry widget.
    If the Enter key is pressed, it calls the `send_message` function to send the message.

    Args:
        event (Tkinter event object): The event object generated by the key press.
    """
    if event.keysym == "Return":
        send_message()


# Bind the Enter key press event
message_txt.bind("<KeyPress>", on_enter)

# Button for sending messages
button = Button(_input_frame, text="Send", width=1, padx=20, pady=5, background="green", state="disabled")
button.grid(row=0, column=4)


# Function to send messages
def send_message():
    """
    This function retrieves the message from the message entry widget, validates it,
    and displays it in the message box.

    1. It retrieves the message text from the `message_txt` entry widget.
    2. It checks if the message is not empty.
    3. If the message is not empty:
        - It enables editing of the message box (`messages_box_txt`).
        - It inserts the message text followed by a newline character ("\n") at the end of the message box.
        - It disables editing of the message box again.
        - It clears the message entry widget.
        - It scrolls the message box to the bottom to show the newly sent message.
    """
    message = message_txt.get()
    if message == "QUIT":
        asyncio.run(exit_server(socket_server, message))
        raise SystemExit
    if message != "":
        messages_box_txt.configure(state='normal')
        messages_box_txt.insert(END, f"You : ", "normaltext")
        messages_box_txt.insert(END, f"{message}\n", "user_msg")
        messages_box_txt.configure(state='disabled')
        message_txt.delete(0, END)
        messages_box_txt.see(END)

        asyncio.run(send_message_to_server(socket_server, message))


# Function to validate the username
import re


def validate_username(text):
    """
    Validates the username entered by the user, ensuring it meets the following criteria:
    - Cannot be empty.
    - Contains only alphanumeric characters (a-z, A-Z, 0-9), underscores ("_"), and must start and end with an alphanumeric character.
    - Consists exclusively of English letters and numbers.

    Args:
        text (str): The username text to validate.

    Returns:
        bool: True if the username is valid, False otherwise.
    """
    # English letters, numbers, and underscore
    pattern = r"^[a-zA-Z0-9_]+(?:[a-zA-Z0-9_]*)$"
    return bool(re.match(pattern, text)) and text != ""


# Function to handle the login process
def login():
    """
    Manages the login process, handling user interface updates and chat connection.

    This function:
    1. Retrieves the entered username from the `username_txt` entry widget.
    2. Validates the username using the external `validate_username` function.
    3. If the username is valid:
        - Transitions the user interface:
            - Hides the login frame (`_login_frame`).
            - Enables the send button (`button`) and message entry (`message_txt`).
            - Shows the message frame (`_message_frame`) and input frame (`_input_frame`).
        - Initiates chat connection:
            - Establishes a connection with the chat server using the `new_user` function.
            - Displays the welcome message and server response in the message box (`messages_box_txt`).
    """
    entered_username = username_txt.get()
    if validate_username(entered_username):
        username_error_lbl.config(state=DISABLED)
        # Transition user interface
        _login_frame.pack_forget()
        button.config(state=NORMAL)
        message_txt.config(state=NORMAL)
        message_txt.focus_set()
        _message_frame.pack(expand=True, fill=BOTH)
        _input_frame.pack()

        # print all message that save in database
        all_message = SavedMessage.select()
        print_all_save_message(all_message)
        
        # Initiate chat connection
        try:
            welcome_message, server_message = asyncio.run(new_user(entered_username))
        except:
            raise SystemExit
        messages_box_txt.configure(state='normal')
        messages_box_txt.insert(END, f"\n\t{welcome_message}\n", "server")
        messages_box_txt.insert(END, f"\t{server_message}\n", "new_user")
        messages_box_txt.configure(state='disabled')
        messages_box_txt.see(END)
        
        # Start a separate thread to handle receiving new messages in the background
        handel_message_thread = threading.Thread(target=get_new_message, args=(socket_server,))
        handel_message_thread.daemon = True
        handel_message_thread.start()
    else:
        username_error_lbl.config(state=NORMAL)


# Connect the login button to the login function
login_btn.config(command=login)
# Pack the login frame onto the main container frame
_login_frame.pack()
# Connect the send message button to the send_message function
button.config(command=send_message)


def get_new_message(sock: socket.socket) -> None:
    """
    Continuously listens for and receives messages from the provided socket.

    This function operates in a loop, attempting to receive messages
    until a user exit signal is received. On successful message reception,
    it removes any leading or trailing whitespace characters and returns the
    message content. Otherwise, it returns an empty string.

    This function is typically used in a separate thread to enable asynchronous
    message reception from the server.

    Args:
        sock (socket.socket): The socket object used for server communication.

    Returns:
        str: The received message (without leading/trailing whitespace) or
        an empty string if there's an error or user exit.
    """
    # Flag to indicate user exit
    exit_user: bool = False
    while not exit_user:
        try:
            # Attempt to receive message from server
            msg = sock.recv(1024).decode()
            # Return message content without leading/trailing whitespace
            add_message_to_text_box(msg.strip())
        except:
            # Handle exceptions during message reception
            raise SystemExit


def add_message_to_text_box(server_message):
    """
        Updates the text box with a new message received from the server,
        handling potential exceptions gracefully.

        Args:
            server_message (str): The message content received from the server.
    """
    messages_box_txt.configure(state='normal')
    try:
        if "ENTERED" in server_message:
            # Insert server message with newline and "server_enter" tag
            messages_box_txt.insert(END, f"\r{server_message}\n", "server_enter")
        elif "LEFT" in server_message:
            # Insert server message with newline and "server_exit" tag
            messages_box_txt.insert(END, f"\r{server_message}\n", "server_exit")
        else:
            # Insert server message with newline and "server" tag
            messages_box_txt.insert(END, f"\r{server_message}\n", "server")
    except:
        pass
    finally:
        # Disable editing after update
        messages_box_txt.configure(state='disabled')
        messages_box_txt.see(END)


def print_all_save_message(all_msg):
    messages_box_txt.configure(state='normal')
    # Get the 100 last Message DESC
    get_100_last_message = all_msg[::-1][:100][::-1]
    
    # Show the Messages
    for msg in get_100_last_message:
        if "ENTERED" in msg.content:
            messages_box_txt.insert(END, f"{msg.content}\n", "server_enter")  
        elif "LEFT" in msg.content:
            messages_box_txt.insert(END, f"{msg.content}\n", "server_exit")
        else:
            messages_box_txt.insert(END, f"{msg.username} : ", "server")
            messages_box_txt.insert(END, f"{msg.content}\n", "normaltext")
            
    messages_box_txt.configure(state='disabled')
    messages_box_txt.see(END)


def right_click(event, entry_widget):
    # ایجاد منوی زمینه‌ای
    popup_menu = Menu(root, tearoff=0)
    popup_menu.add_command(label="Cut", command=lambda: cut(entry_widget))
    popup_menu.add_command(label="Copy", command=lambda: copy(entry_widget))
    if str(event.widget) == ".!frame.!frame2.!text":
        pass
    else:
        popup_menu.add_command(label="Paste", command=lambda: paste(entry_widget))
    
    # نمایش منو در مکان نشانگر موس
    try:
        popup_menu.tk_popup(event.x_root, event.y_root)
    finally:
        # بستن منو پس از انتخاب گزینه
        popup_menu.grab_release()


def paste(entry_widget):
    # Get Clipboard Text
    clipboard_content = root.clipboard_get()
    # Set Clipboard Text to entry_widget
    entry_widget.insert('end', clipboard_content)


def copy(entry_widget):
    root.clipboard_clear()
    root.clipboard_append(entry_widget.selection_get())


def cut(entry_widget):
    entry_widget.event_generate('<<Cut>>')
    


message_txt.bind('<Button-3>', lambda event: right_click(event, message_txt))
messages_box_txt.bind('<Button-3>', lambda event: right_click(event, message_txt))


# Start the main event loop
root.mainloop()
